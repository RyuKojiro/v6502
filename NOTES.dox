/**
\mainpage

The v6502 infrastructure currently consists of two major sections, and their API
subsections:

- \subpage as (as6502)
	- \ref parser.h
		- \ref parser_translit
		- \ref parser_line
		- \ref parser_help
	- \ref linectl.h
		- \ref linectl
	- \ref codegen.h
		- \ref codegen
	- \ref error.h
		- \ref as_error
	- \ref symbols.h
		- \ref sym_lifecycle
		- \ref sym_access
		- \ref sym_ez
		- \ref sym_rep
	- \ref object.h
		- \ref obj_lifecycle
		- \ref obj_access
		- \ref obj_mutate
- \subpage vm (v6502)
	- \ref cpu.h
		- \ref cpu_lifecycle
		- \ref cpu_exec
	- \ref mem.h
		- \ref mem_lifecycle
		- \ref mem_access

\page as Assembler
\section usage Arguments and Usage

as6502 [-SW] [\a file ...]

Any number of files may be specified and they will all be assembled,
individually. There currently is no linker in the v6502 stack, as6502 just
outputs the raw binaries ready-to-execute. If no files are specified, as6502
will assemble from stdin, line-buffered.

- -S
	
	Dump assembly with binary results and addresses to stdout for verification
	of what is being produced. \see \ref debug

- -W
	
	Emit warnings where possible, and attempt to recover, then continue assembly.

\section notes Notes

When assembling from stdin, label parsing and dereferencing is not supported.
This is because the labels are all determined in advance on a first pass that
only cares about instruction size, and then the second pass actually begins
converting the assembly to machine code, while dereferencing the labels along
the way via the pre-built table.

\section design Design

The assembler makes two passes over the source, and aims to be as efficient as
possible, while still exposing powerful access to the assembly process.

-# Reference calculation; conversion of variable names and labels to addresses.
	Preallocation of object blobs based on dot-prefixed directives.
-# (Final) (Only pass when using stdin)
	Population of dot-prefixed lines (e.g. Allocation of .data blocks, .words, .org.)
	Conversion of instructions to machine code.

\section debug Debugging

Debug output logging has been added to allow printing of the assembly process,
as it happens, the outlook is column oriented and can be seen below. The column
headers have been added, and the middle 208 lines omitted for clarity.

\code
Offset  Op Lo Hi   Line  Instruction
------  -- -- --   ----  -----------
0x0000: 20 03 00 -   15: jsr $0003
0x0003: 20 38 00 -   16: jsr $0038
0x0006: 20 04 00 -   19: jsr $0004
0x0009: 20 1e 00 -   20: jsr $001e
0x000c: 60       -   21: rts
0x000d: a9 02    -   25: lda #2
0x000f: 85 02    -   26: sta *$
      … 208 lines ommitted …
0x0128: a6 03    -  234: ldx *$03
0x012a: a9 00    -  235: lda #0
0x012c: 81 10 00 -  236: sta ($10,x)
0x012f: 60       -  237: rts
0x0130: a2 00    -  241: ldx #0
0x0132: ea       -  243: nop
0x0133: ea       -  244: nop
0x0134: ca       -  245: dex
0x0135: d0 0c    -  246: bne $0c
0x0137: 60       -  247: rts
\endcode

\page vm Virtual Machine

The simplest fault tolerant implementation of a v6502 instance is as follows:

\code
#include "cpu.h"
#include "mem.h"

void fault(void *ctx, const char *e) {
	((int)*ctx)++;
}

int main(int argc, const char * argv[])
{
	int faulted = 0;
	
	v6502_cpu *cpu = v6502_createCPU();
	cpu->memory = v6502_createMemory(2048);
	cpu->fault_callback = fault;
	cpu->fault_context = &faulted;

	v6502_reset(cpu);

	while (!faulted) {
		v6502_step(cpu);
	}

	v6502_destroyMemory(cpu->memory);
	v6502_destroyCPU(cpu);
}
\endcode

*/